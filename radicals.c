#include "kanji_db.h"
#include "radicals.h"
#include "util.h"

static struct {
	/* 部首の kanji_db() へのインデックス */
	unsigned ki;

	unsigned stroke_cnt;
} radicals[RADICAL_COUNT];

static void prepare(void)
{
	unsigned i, count = 0, stroke_cnt = 0;

	if (radicals[1].ki)
		return;

	if (kanji_from_rsc_index(0)->cutoff_type != 3)
		DIE(0, "【一】の区切りタイプが設定されていない。");

	for (i = 0; count != RADICAL_COUNT; i++) {
		struct kanji_entry const *k = kanji_from_rsc_index(i);

		if (k->cutoff_type < 2)
			continue;

		radicals[count].ki = k - kanji_db();
		if (k->cutoff_type == 3)
			stroke_cnt++;
		radicals[count].stroke_cnt = stroke_cnt;
		count++;
	}
}

static uint8_t radnums[] = {
0x01,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,
0x16,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x25,0x26,0x27,
0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,
0x48,0x49,0x4b,0x4c,0x4d,0x4e,0x4f,0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,
0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,
0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,
0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,
0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,
0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,
0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,
0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,
};

int radical_num(int index)
{
	if (index < 0 || index >= RADICAL_COUNT) DIE(0, "%d", index);

	return radnums[index];
}

void radical_coverage_next(struct radical_coverage *cov)
{
	if (cov->rsc_key_end < cov->rsc_key_start)
		DIE(0, "%u < %u", cov->rsc_key_end, cov->rsc_key_start);
	if (cov->rad_i == 0xffff)
		DIE(0, "既に radical_coverage_done 状態です。");

	prepare();

	while (cov->rad_i < RADICAL_COUNT) {
		cov->current = radicals[cov->rad_i].ki;
		cov->stroke_cnt = radicals[cov->rad_i].stroke_cnt;
		cov->rad_i++;

		if (kanji_db()[cov->current].rsc_sort_key >= cov->rsc_key_end)
			break;
		if (cov->rad_i < RADICAL_COUNT) {
			unsigned end = kanji_db()[radicals[cov->rad_i].ki]
				.rsc_sort_key;
			if (end <= cov->rsc_key_start)
				continue;
		}

		return;
	}

	cov->rad_i = 0xffff;
}
